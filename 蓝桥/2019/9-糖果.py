'''
糖果店的老板一共有M 种口味的糖果出售。为了方便描述，我们将M种口味编号1~M。
小明希望能品尝到所有口味的糖果。遗憾的是老板并不单独出售糖果，而是K颗一包整包出售。
幸好糖果包装上注明了其中K 颗糖果的口味，所以小明可以在买之前就知道每包内的糖果口味。
给定N 包糖果，请你计算小明最少买几包，就可以品尝到所有口味的糖果。

【输入】
第一行包含三个整数N、M 和K。
接下来N 行每行K 这整数T1,T2,...,TK，代表一包糖果的口味。
1<=N<=100，1<=M<=20，1<=K<=20，1<=Ti<=M。
【输出】
一个整数表示答案。如果小明无法品尝所有口味，输出-1。

样例输入
6 5 3
1 1 2
1 2 3
1 1 3
2 3 5
5 4 2
5 1 2
样例输出
2
'''
N,M,K = input().split()
N,M,K = map(lambda x:int(x),[N,M,K])
# 题目中说m最大是20.最多20中口味
tot=(1<<M)-1 #表示的是所有口味的糖都存在的组合。即11111，5个1
# dp[tot]就是代表的，下方的代码结束后，所有的口味都拥有的糖果包数目

dp = [-1 for i in range(tot+1)]
# 最开始记录的是，所有口味的组合，是否在糖果中能找到。如果有该糖果，为1，没有该糖果就是-1
# dp记录口味是i时，需要的最少糖果包的数量
st = [-1 for i in range(N)]
# st记录第i包糖的口味

for i in range(N):
    string = input().split()
    string = list(map(lambda x:int(x),string))
    taste = 0
    for j in range(K):
        taste |= (1<<(string[j]-1)) #taste是压缩后的糖果口味组合.二进制的与运算
    
    dp[taste] = 1 #存在该口味组合
    st[i] = taste #st记录了N包糖果的口味组合


for i in range(M+1):#遍历每一个口味组合
    if(dp[i]!=-1):#如果该口味组合存在。
        # 并随着下面循环体的进行在改变。由一包糖果变为多包糖果
        for j in range(N):
            taste = st[j]#遍历每一包糖的口味组合

            # 如果该组合和这包糖的口味组合取并集不存在的话，
            # 即有组合糖果包含多包糖果的口味这种情况不存在
            
            # 或者说虽然这个组合糖果存在，但是他不如第i个组合+1包糖果包含的少
            # 因为i|taste类型的糖果就是dp[i]和未经循环体的dp[taste]的组合。本来应该直接相加
            # 但是由于dp在变化。而这包糖果肯定存在。所以直接dp[i]+1即可

            # i|taste肯定>=i和taste
            if(dp[i|taste]==-1 or dp[i|taste]>dp[i]+1):#状态转移
                dp[i|taste] = dp[i]+1

print(dp[tot]) #得到所有口味tot的最少糖果包数量