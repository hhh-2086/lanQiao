'''
下图给出了一个迷宫的平面图，其中标记为1 的为障碍，标记为0 的为可以通行的地方。
010000
000100
001001
110000
迷宫的入口为左上角，出口为右下角，在迷宫中，
只能从一个位置走到这个它的上、下、左、右四个方向之一。
对于上面的迷宫，从入口开始，
可以按DRRURRDDDR 的顺序通过迷宫，一共10 步。
其中D、U、L、R 分别表示向下、向上、向左、向右走。
对于下面这个更复杂的迷宫（30 行50 列），
请找出一种通过迷宫的方式，其使用的步数最少，在步数最少的前提下，
请找出字典序最小的一个作为答案。
请注意在字典序中D<L<R<U。
'''

# BFS算法
# 广度优先算法

# 正确答案：DDDDRRURRRRRRDRRRRDDDLDDRDDDDDDDDDDDDRDDRRRURRUURRDDDDRDRRRRRRDRRURRDDDRRRRUURUUUUUUULULLUUUURRRRUULLLUUUULLUUULUURRURRURURRRDDRRRRRDDRRDDLLLDDRRDDRDDLDDDLLDDLLLDLDDDLDDRRRRRRRRRDDDDDDRR

mapData = ["01010101001011001001010110010110100100001000101010",
    '00001000100000101010010000100000001001100110100101',
    '01111011010010001000001101001011100011000000010000',
    '01000000001010100011010000101000001010101011001011',
    '00011111000000101000010010100010100000101100000000',
    '11001000110101000010101100011010011010101011110111',
    '00011011010101001001001010000001000101001110000000',
    '10100000101000100110101010111110011000010000111010',
    '00111000001010100001100010000001000101001100001001',
    '11000110100001110010001001010101010101010001101000',
    '00010000100100000101001010101110100010101010000101',
    '11100100101001001000010000010101010100100100010100',
    '00000010000000101011001111010001100000101010100011',
    '10101010011100001000011000010110011110110100001000',
    '10101010100001101010100101000010100000111011101001',
    '10000000101100010000101100101101001011100000000100',
    '10101001000000010100100001000100000100011110101001',
    '00101001010101101001010100011010101101110000110101',
    '11001010000100001100000010100101000001000111000010',
    '00001000110000110101101000000100101001001000011101',
    '10100101000101000000001110110010110101101010100001',
    '00101000010000110101010000100010001001000100010101',
    '10100001000110010001000010101001010101011111010010',
    '00000100101000000110010100101001000001000000000010',
    '11010000001001110111001001000011101001011011101000',
    '00000110100010001000100000001000011101000000110011',
    '10101000101000100010001111100010101001010000001000',
    '10000010100101001010110000000100101010001011101000',
    '00111100001000010000000110111000000001000000001011',
    '10000001100111010111010001000110111010101101111000']
row = 30
col = 50
mapMark = [[''for i in range(col)]for j in range(row)]
mapMark[0][0]='S'
# 存储路径，每一个点只记录前驱结点。
# 因为每一个点的后继节点会有多个，但是前驱节点只有一个

node = (0,0)
# 每一个点还要记录上一个点。方便回溯
road = [node]
while(True):
    node = road.pop(0)
    if(node == (row-1,col-1)):break
    (i,j) = node
    # 向下走
    if(i+1<row and mapMark[i+1][j]=='' and mapData[i+1][j]=='0'):
        road.append((i+1,j))
        mapMark[i+1][j] = 'U'
    # 向左走
    if(j-1>=0 and mapMark[i][j-1]=='' and mapData[i][j-1]=='0'):
        road.append((i,j-1))
        mapMark[i][j-1] = 'R'
    # 向右走
    if(j+1<col and mapMark[i][j+1]=='' and mapData[i][j+1]=='0'):
        road.append((i,j+1))
        mapMark[i][j+1] = 'L'
    # 向上走
    if(i-1>=0 and mapMark[i-1][j]=='' and mapData[i-1][j]=='0'):
        road.append((i-1,j))
        mapMark[i-1][j] = 'D'

# 回溯输出
result  = ''
i,j = row-1,col-1
count = 0
while(count<200):
    count+=1
    if(mapMark[i][j]=='U'):
        i,j = i-1,j
        result+='D'
        # print(i,j)
    elif(mapMark[i][j]=='L'):
        i,j = i,j-1
        result+='R'
        # print(i,j)
    elif(mapMark[i][j]=='R'):
        i,j = i,j+1
        result+='L'
        # print(i,j)
    elif(mapMark[i][j]=='D'):
        i,j = i+1,j
        result+='U'
        # print(i,j)
    if(i==0 and j==0):break
print(count)
print(result[-1::-1])
# count = 186
# result= DDDDRRURRRRRRDRRRRDDDLDDRDDDDDDDDDDDDRDDRRRURRUURRDDDDRDRRRRRRDRRURRDDDRRRRUURUUUUUUULULLUUUURRRRUULLLUUUULLUUULUURRURRURURRRDDRRRRRDDRRDDLLLDDRRDDRDDLDDDLLDDLLLDLDDDLDDRRRRRRRRRDDDDDDRR
